{
  
    
        "post0": {
            "title": "User-configurable Keymaps",
            "content": "While developing the BDV Preferences dialog, a &quot;pattern&quot; has emerged of how we wire up the shortcut and action definitions. This tutorial explains the current recommended way of doing that. We give some background about using ui-behaviour etc. Feel free to just skip to the end for the recommended pattern. . Introduction . In BigDataViewer 10.4 we added a Preferences dialog. This makes settings more user accessible, that previously could only be made through editing config files. In particular, users can now easily override BigDataViewer keybindings to their liking. . It is also possible to define and switch between multiple sets of keybindings. For example, in Mastodon, we have predefined keymaps that have . basic BDV key bindings, but many shortcuts remapped to navigate along a cell lineage, or | full BDV key bindings, at the expense of more complicated shortcuts for cell lineage navigation. | . On top of these users can define their own completely customised keymaps. . This is all based on ui-bahaviour, which several tools (BDV-based and otherwise) already use for managing shortcuts. While developing the Mastodon Preferences dialog, and now carrying over to BigDataViewer, a pattern has emerged of how we wire up the shortcut and action definitions. It would be great if this would become a blueprint for actions in other tools, because a) that will make the code easier to understand and b) facilitate reuse of action definitions across projects. . We work towards the recommended pattern, from scratch, in a series of examples that you can also find on github. . %%loadFromPOM &lt;repository&gt; &lt;id&gt;scijava.public&lt;/id&gt; &lt;url&gt;https://maven.scijava.org/content/groups/public&lt;/url&gt; &lt;/repository&gt; &lt;dependency&gt; &lt;groupId&gt;sc.fiji&lt;/groupId&gt; &lt;artifactId&gt;bigdataviewer-core&lt;/artifactId&gt; &lt;version&gt;10.4.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.scijava&lt;/groupId&gt; &lt;artifactId&gt;ui-behaviour&lt;/artifactId&gt; &lt;version&gt;2.0.7&lt;/version&gt; &lt;/dependency&gt; . Setting up shortcuts through ui-behaviour . Lets look at a basic example of integrating ui-beahviour in a AWT/Swing application. . We need a minimal application to play with: MainPanel is a JPanel containing (only) a single JLabel displaying the text &quot;hello&quot;. The displayed text can be changed by the setText(String) method. We will use this to define different mock &quot;actions&quot;. . public class MainPanel extends JPanel { private final JLabel label; public MainPanel() { setLayout( new BorderLayout() ); setBorder( new EmptyBorder( 0, 20, 0, 0 ) ); setFocusable( true ); label = new JLabel( &quot;hello&quot; ); add( label, BorderLayout.CENTER ); } public void setText( final String text ) { label.setText( text ); } } . Let&#39;s instantiate a MainPanel and show it in a JFrame. . var frame = new JFrame( &quot;Keymaps Demo&quot; ); var panel = new MainPanel(); frame.add( panel ); frame.setPreferredSize( new Dimension( 200, 100 ) ); frame.pack(); frame.setVisible( true ); . . To set up ui-behaviour for the panel, we first need an instance of InputActionBindings . import org.scijava.ui.behaviour.util.InputActionBindings; var bindings = new InputActionBindings(); . InputActionBindings bind inputs to actions. . This is of course exactly what AWT/Swing&#39;s Key Bindings framework (InputMap, ActionMap) does. InputActionBindings adds very little over that; basically only more convenient InputMap chaining. . Side note: The initial purpose of ui-behaviour was to offer a similar framework for mouse clicks, scrolls, drags, etc. Modeled after InputMap and ActionMap, there are InputTriggerMap and BehaviourMap. Analogous to InputActionBindings there is TriggerBehaviourBindings. . Anyway, we connect the InputActionBindings instance to our MainPanel as follows. . SwingUtilities.replaceUIActionMap( panel, bindings.getConcatenatedActionMap() ); SwingUtilities.replaceUIInputMap( panel, JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT, bindings.getConcatenatedInputMap() ); . InputActionBindings manages a chain of InputMap/ActionMap pairs. An Actions object encapsulates one such pair, and feeds new action definitions into it. We create a new Actions (the constructor arguments don&#39;t matter for now) ... . import org.scijava.ui.behaviour.io.InputTriggerConfig; import org.scijava.ui.behaviour.util.Actions; var actions = new Actions( new InputTriggerConfig(), &quot;demo&quot; ); . ... and we add the pair to our InputActionBindings under the name &quot;actions&quot;. . actions.install( bindings, &quot;actions&quot; ); . (We could use the name later to remove, replace, or temporarily block the InputMap/ActionMap pair.) . The actions instance is now connected to the panel via bindings. We can finally use it to add new shortcuts. . actions.runnableAction( () -&gt; panel.setText( &quot;Action A triggered&quot; ), &quot;Action A&quot;, &quot;SPACE&quot;, &quot;A&quot; ); . The actions.runnableAction method takes the following arguments . public void runnableAction( final Runnable runnable, final String name, final String... defaultKeyStrokes ) . A Runnable to run when the action is triggered. | A unique name for the action (this will be used as the actions key in the underlying InputMap/ActionMap. | Zero or more keystrokes that should trigger the action. | Here for example, the Runnable sets the text &quot;Action A triggered&quot; in the panel label. It is added under the name &quot;Action A&quot;, and triggered by the &quot;SPACE&quot; key, or the &quot;A&quot; key by default. The syntax for key strokes is described here. . Let&#39;s add a few more actions. . actions.runnableAction( () -&gt; panel.setText( &quot;Action B triggered&quot; ), &quot;Action B&quot;, &quot;B&quot;, &quot;shift B&quot; ); actions.runnableAction( () -&gt; panel.setText( &quot;Action C triggered&quot; ), &quot;Action C&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;0&quot; ); . Now we can use these defined shortcuts to run these three actions (which will change the text label to &quot;Action A/B/C triggered&quot;. You can find the full example on github. . Making shortcuts configurable . Another goal of ui-behaviour is to make mouse and key bindings easily configurable by the user (for example through config files). . This is the purpose of the Actions constructor arguments . var action = new Actions( new InputTriggerConfig(), &quot;demo&quot; ); . The first argument is a InputTriggerConfig, and after that one or more String contexts are given (more on that later). . The InputTriggerConfig contains is basically a map from action names to key bindings. When adding a new action, for example like this: . actions.runnableAction( () -&gt; mainPanel.setText( &quot;Action B triggered&quot; ), &quot;Action B&quot;, &quot;B&quot;, &quot;shift B&quot; ); . then actions will first look into its InputTriggerConfig to check whether any key binding is associated with the respective action name (&quot;Action B&quot;). If nothing is defined in the InputTriggerConfig then (and only then) the specified default key bindings will be used (&quot;B&quot; and &quot;shift B&quot;). . Loading shortcuts from a config file . So far, we just used a new, empty InputTriggerConfig, meaning we just get the specified defaults, which is exactly what we want for prototyping. If the project becomes more mature, and we want to change the config from outside, we can load the InputTriggerConfig from a config file. . import org.scijava.ui.behaviour.io.yaml.YamlConfigIO; Reader reader = new FileReader( &quot;config.yaml&quot; ); var config = new InputTriggerConfig( YamlConfigIO.read( reader ) ); . The config.yaml file looks like this: . - !mapping action: Action A contexts: [demo] triggers: [SPACE, A] - !mapping action: Action B contexts: [demo] triggers: [N] . The format should be more or less self-explanatory. . The loaded config should now map the String &quot;Action A&quot; to the Set of Strings {&quot;SPACE&quot;, &quot;A&quot;}, and &quot;Action B&quot; to {&quot;N&quot;}. We could set up actions with the loaded config in the constructor, and then define the same actions as in the previous example. . Alternatively, we can just update the existing Actions with the new config. . actions.updateKeyConfig(config, false); . The config contains bindings for &quot;Action A&quot; and &quot;Action B&quot;. These will override the specified default bindings. So &quot;Action A&quot; will be triggered by the &quot;SPACE&quot; or &quot;A&quot; keys, and &quot;Action B&quot; will be triggered by &quot;N&quot;. . The config doesn&#39;t specify anything for &quot;Action C&quot;, so that will be triggered by the programmatically specified defaults, that is, &quot;1&quot;, &quot;2&quot;, etc. . Action context . Besides the InputTriggerConfig, the Actions constructor also requires one ore more String... context arguments. . The idea is that the same action (or at least action name) might occur in different contexts, that is, different tools, different windows of the same tool, etc. For example, an action named &quot;Undo&quot; could occur in many contexts and it would be nice to be able to assign different shortcuts, depending on context. . Therefore, an InputTriggerConfig does not directly map action to shortcuts, but rather maps (action, context) pairs to shortcuts, where action and context are both Strings. So, for example, (&quot;Undo&quot;, &quot;bdv&quot;) can map to a different shortcut than (&quot;Undo&quot;, &quot;paintera&quot;). . The context arguments given in the Actions constructor specify which subsets of key bindings defined in the InputTriggerConfig should be considered. In the above example, we have . var actions = new Actions( config, &quot;demo&quot; ) . This actions will pick up bindings for (&quot;Undo&quot;, &quot;demo&quot;) from the config, but not (&quot;Undo&quot;, &quot;bdv&quot;) for example. . Disabled actions . There is a special trigger &quot;not mapped&quot; that can be used to specify that a particular action should not be associated to any shortcut. For example, if we add . - !mapping action: Action C contexts: [demo] triggers: [not mapped] . to the config.yaml file, then &quot;Action C&quot; will be disabled, that is, the programmatic defaults &quot;1&quot;, &quot;2&quot;, etc., will not be used. . You can find the full example on github. . Configuring shortcuts through the UI . Being able to define shortcuts through a config file is useful. The config files can be edited, and distributed between different users or computers. . Even more comfortable is to be able to modify shortcuts directly through the UI, at runtime. . Preferences dialog . For this, we use bdv.ui.settings.SettingsPanel. This panel implements a typical Preferences layout (like it&#39;s used in Eclipse, for example) with a tree of preferences sections on the left, the selected section on the right, and Apply, Ok, Cancel buttons on the bottom. . The following PrefererencesDialog contains only the SettingsPanel, and a method addPage() to adds new sections (bdv.ui.settings.SettingsPage) to the preferences tree. . import bdv.ui.settings.SettingsPage; import bdv.ui.settings.SettingsPanel; public class PreferencesDialog extends JDialog { private final SettingsPanel settingsPanel; public PreferencesDialog( final Frame owner ) { super( owner, &quot;Preferences&quot;, false ); settingsPanel = new SettingsPanel(); settingsPanel.onOk( () -&gt; setVisible( false ) ); settingsPanel.onCancel( () -&gt; setVisible( false ) ); setDefaultCloseOperation( WindowConstants.HIDE_ON_CLOSE ); addWindowListener( new WindowAdapter() { @Override public void windowClosing( final WindowEvent e ) { settingsPanel.cancel(); } } ); getContentPane().add( settingsPanel, BorderLayout.CENTER ); pack(); } public void addPage( final SettingsPage page ) { settingsPanel.addPage( page ); pack(); } } . Let&#39;s instantiate a PreferencesDialog for our example, and add a keyboard shortcut (command-comma or control-comma) to show it. . var preferencesDialog = new PreferencesDialog( frame ); actions.runnableAction( () -&gt; preferencesDialog.setVisible( !preferencesDialog.isVisible() ), &quot;Preferences&quot;, &quot;meta COMMA&quot;, &quot;ctrl COMMA&quot; ); . Next, we want to add a preferences section for configuring shortcuts. There is bdv.ui.keymap.KeymapSettingsPage that we can readily use. In the end this will give us something like this: What remains to be done is to fill the settings page with a list of configurable actions. . CommandDescriptions . Specifially, we need to supply the KeymapSettingsPage with a list of existing actions, with short textual descriptions. This is done by creating a CommandDescriptions object and adding the configurable actions. . import org.scijava.ui.behaviour.io.gui.CommandDescriptions; var descriptions = new CommandDescriptions(); descriptions.setKeyconfigContext( &quot;demo&quot; ); descriptions.add( &quot;Action A&quot;, new String[] { &quot;SPACE&quot; }, &quot;trigger Action A&quot; ); descriptions.add( &quot;Action B&quot;, new String[] { &quot;B&quot;, &quot;shift B&quot; }, &quot;trigger Action B&quot; ); . For each action, we add its name and default shortcuts in the same way we did when creating the action, and a short description (this is just for showing to the user, so can be left empty if you&#39;re lazy...). . The other thing we need to supply to the KeymapSettingsPage is a KeymapManager. KeymapManager maintains a set of named Keymaps (some built-in, some user-defined). A Keymap is a simple container for a InputTriggerConfig, adding just a name and support for listeners to be notified when the InputTriggerConfig changes. . Our KeymapManager extends the existing AbstractKeymapManager base class. The only thing that needs to be done is providing one or more default Keymaps. We can build a default keymap from the above descriptions. (But they could also be loaded from resources, build manually, ...) . import bdv.ui.keymap.AbstractKeymapManager; import bdv.ui.keymap.Keymap; var defaultKeymap = new Keymap( &quot;Default&quot;, descriptions.createDefaultKeyconfig() ); /** * Manages a collection of {@link Keymap}. */ public class KeymapManager extends AbstractKeymapManager&lt; KeymapManager &gt; { @Override protected List&lt; Keymap &gt; loadBuiltinStyles() { return Collections.singletonList( defaultKeymap ); } @Override public void saveStyles() { // not implemented. // Here we would save user defined keymaps to YAML files, for example. } } . We create a KeyMapManager instance and add it to the Preferences dialog (via KeymapSettingsPage). . import bdv.ui.keymap.KeymapSettingsPage; var keymapManager = new KeymapManager(); preferencesDialog.addPage( new KeymapSettingsPage( &quot;Keymap&quot;, keymapManager, new KeymapManager(), descriptions ) ); . The KeyMapManager (via its base class) exposes the user-selected keymap. We set that for our actions object. We also add a listener that refreshes actions keybinding when that keymap changes. . var keymap = keymapManager.getForwardSelectedKeymap(); actions.updateKeyConfig( keymap.getConfig(), false ); keymap.updateListeners().add( () -&gt; actions.updateKeyConfig( keymap.getConfig(), false ) ); . true . That&#39;s it. The user can now use the Preferences dialog to define custom keymaps with shortcuts to their liking, and switch between different keymaps. (Use command-comma or control-comma to show the preferences dialog). . You can find the full example on github. . Making action descriptions discoverable . Keeping the list of existing actions (that is, the CommandDescriptions) up to date is tedious. Actions that should appear in the config dialog may be scattered through your own code and dependencies. This can be somewhat automated with CommandDescriptionProviders. These are scijava @Plugins that can be discovered at runtime. . import org.scijava.plugin.Plugin; import org.scijava.ui.behaviour.io.gui.CommandDescriptionProvider; var DEMO_SCOPE = new CommandDescriptionProvider.Scope( &quot;tpietzsch.keymap&quot; ); var DEMO_CONTEXT = &quot;demo&quot;; /* * Command descriptions for all provided commands */ @Plugin( type = CommandDescriptionProvider.class ) public static class MyActionDescriptions extends CommandDescriptionProvider { public MyActionDescriptions() { super( DEMO_SCOPE, DEMO_CONTEXT ); } @Override public void getCommandDescriptions( final CommandDescriptions descriptions ) { descriptions.add( &quot;Action A&quot;, new String[] { &quot;SPACE&quot; }, &quot;trigger Action A&quot; ); descriptions.add( &quot;Action B&quot;, new String[] { &quot;B&quot;, &quot;shift B&quot; }, &quot;trigger Action B&quot; ); } } . For discovery, we use a CommandDescriptionsBuilder . import org.scijava.Context; import org.scijava.plugin.PluginService; import org.scijava.ui.behaviour.io.gui.CommandDescriptionsBuilder; var context = new Context( PluginService.class ); var builder = new CommandDescriptionsBuilder(); context.inject( builder ); builder.discoverProviders( DEMO_SCOPE ); . Note the use of DEMO_SCOPE here. The same scope is also given in the MyActionDescriptions constructor. The discoverProviders() method takes an optional scope argument, and will only discover CommandDescriptionProvider that match this scope. If no scope is given, all CommandDescriptionProvider on the classpath will be discovered. For example within Fiji, that would include actions from Mastodon and BigDataViewer. . Unfortunately, the @Plugin annotations do not work for classes defined in JShell (used by this notebook). As a workaround, we can add MyActionDescriptions manually. . builder.addManually( new MyActionDescriptions(), DEMO_CONTEXT ); . After we add everything we need to the builder, we can get the Descriptions. . var descriptions = builder.build(); . You can find the full example on github. . Recommended pattern for defining actions . Action definitions in BigDataViewer and Mastodon are organized in the following way. . A set of related actions is collected into a MyActions (for example) class. Action names and default shortcuts are defined as public static final constants, because they are used both for defining the actions, and for creating action Descriptions. . The actions contained in MyActions are described in a public static inner class Descriptions extends CommandDescriptionProvider. . In the Descriptions constructor, we give a scope for the respective library / tool. Ideally, the scope should be defined public static somewhere so that is can easily used outside the component to discover its actions. For example, BigDataViewer uses this scope. If another tool (BigStitcher, BigWarp, etc.) wants to include BDV shortcuts into its customizable keymaps, they can be easily discovered like that. . import org.scijava.plugin.Plugin; import org.scijava.ui.behaviour.io.gui.CommandDescriptionProvider; final var DEMO_SCOPE = new CommandDescriptionProvider.Scope( &quot;tpietzsch.keymap-idiom&quot; ); final var DEMO_CONTEXT = &quot;demo&quot;; public class MyActions { // define action name constants public static final String ACTION_A = &quot;Action A&quot;; public static final String ACTION_B = &quot;Action B&quot;; public static final String PREFERENCES = &quot;Preferences&quot;; // define default shortcut constants public static final String[] ACTION_A_KEYS = { &quot;SPACE&quot; }; public static final String[] ACTION_B_KEYS = { &quot;B&quot;, &quot;shift B&quot; }; public static final String[] PREFERENCES_KEYS = { &quot;meta COMMA&quot;, &quot;ctrl COMMA&quot; }; /* * Command descriptions for all provided commands */ @Plugin( type = CommandDescriptionProvider.class ) public static class Descriptions extends CommandDescriptionProvider { public Descriptions() { super( DEMO_SCOPE, DEMO_CONTEXT ); } @Override public void getCommandDescriptions( final CommandDescriptions descriptions ) { descriptions.add( ACTION_A, ACTION_A_KEYS, &quot;trigger Action A&quot; ); descriptions.add( ACTION_B, ACTION_B_KEYS, &quot;trigger Action B&quot; ); descriptions.add( PREFERENCES, PREFERENCES_KEYS, &quot;Show the Preferences dialog.&quot; ); } } /** * Install into the specified {@link Actions}. */ public static void install( final Actions actions, final MainPanel mainPanel, final PreferencesDialog preferencesDialog ) { actions.runnableAction( () -&gt; mainPanel.setText( &quot;Action A triggered&quot; ), ACTION_A, ACTION_A_KEYS ); actions.runnableAction( () -&gt; mainPanel.setText( &quot;Action B triggered&quot; ), ACTION_B, ACTION_B_KEYS ); actions.runnableAction( () -&gt; preferencesDialog.setVisible( !preferencesDialog.isVisible() ), PREFERENCES, PREFERENCES_KEYS ); } } . MyActions contains one install method that installs all actions into a provided Actions argument. Ideally, MyActions is stateless, and install method is static. . The remaining arguments to install are whatever is needed to create the actions. In the example, the mainPanel is needed to create &quot;Action A&quot; and &quot;Action B&quot;, and the preferencesDialog is needed to create the action to show/hide it. . So, MyActions.install(...) is called to install into a provided Actions. Usually every frame/panel in the application should have an Actions instance, which is linked to the KeymapManager so that keymap updates propagate correctly. . And that&#39;s it... This is currently the recommended way to structure and bundle action definitions. You can find the full example on github. . See BigDataViewer&#39;s NavigationActions as an example &quot;in the wild&quot;. For behaviours (mouse gestures, etc.) the structure is the same. See BigDataViewer&#39;s TransformEventHandler2D for example. .",
            "url": "https://imglib.github.io/imglib2-blog/ui-behaviour/bigdataviewer/2022/08/08/keymaps.html",
            "relUrl": "/ui-behaviour/bigdataviewer/2022/08/08/keymaps.html",
            "date": " • Aug 8, 2022"
        }
        
    
  
    
        ,"post1": {
            "title": "Setup the IJava jupyter kernel",
            "content": "In this blog, we will show code snippets and examples to make the best use of ImgLib2, BigDataViewer, and friends. ImgLib2 is written to be fast and we will run code that needs to be compiled, so we cannot use any of the various interpreted scripting languages like Python, Groovy, or Javascript. Instead, we will use the JShell tool that you can use directly in a terminal or through Spencer Park’s IJava jupyter kernel. You can also follow these tutorials in your own Java project and use your preferred IDE, but Jupyter notebooks are a great teaching tool. Since jupyter is written in Python and most popular with the Python community, let’s follow their ways and first thing create a virtual environment with conda. The lack of version controlled dependency management for Python projects makes it necessary that practically every project must run in a container or virtual environment because the dependencies of different projects almost inevitably collide. Conda is the most popular of several attempts to address this situation. Conda cannot currently be installed from the default Ubuntu repositories, so much about that, but the installation instructions are tolerable, there is a PPA. Now let’s create an environment for jupyter: . conda create -n jshell-jupyter python=3 conda init bash conda activate jshell-jupyter conda install jupyter . You will also need a modern Java and Maven on your system, so if you have not yet done so, install it: . sudo apt install openjdk-17-jdk maven . The original IJava kernel currently does not build with Java 17 or 18, so we use Philipp Hanslovsky’s fork and build and install both the kernel installer and the IJava Jupyter kernel: . git clone https://github.com/hanslovsky/Jupyter-kernel-installer-gradle.git cd Jupyter-kernel-installer-gradle/ git checkout try-upgrade-gradle ./gradlew publishToMavenLocal cd .. git clone https://github.com/hanslovsky/IJava.git cd IJava/ git checkout hanslovsky/gradle-7.4.2 ./gradlew installKernel . Now check if the kernel is installed, this should print something like this . jupyter kernelspec list Available kernels: java /home/saalfeld/.local/share/jupyter/kernels/java python3 /home/saalfeld/anaconda3/envs/jshell-jupyter/share/jupyter/kernels/python3 . You can now start the jupyter notebook server . jupyter notebook --kernel=java . And experiment with the examples. Spencer Park’s IJava jupyter kernel makes it very easy to include dependencies. You can include the relevant snippets from a Maven POM into a tagged code block, e.g. . %%loadFromPOM &lt;repository&gt; &lt;id&gt;scijava.public&lt;/id&gt; &lt;url&gt;https://maven.scijava.org/content/groups/public&lt;/url&gt; &lt;/repository&gt; &lt;dependency&gt; &lt;groupId&gt;sc.fiji&lt;/groupId&gt; &lt;artifactId&gt;bigdataviewer-vistools&lt;/artifactId&gt; &lt;version&gt;1.0.0-beta-29&lt;/version&gt; &lt;/dependency&gt; . If you prefer to run JShell directly, you can pull in the dependencies from a complete Maven POM with John Pooth’s Maven Jshell plugin . mvn compile com.github.johnpoth:jshell-maven-plugin:1.3:run . Happy JShelling! . P.S.: . The original IJava kernel currently does not build with Java 17 or 18, so if you prefer this over the above fork, or if you do not care about the latest greatest language features in Java 17, then the easiest at this time is to use OpenJDK-11. If you don’t have it yet, install it via conda: . conda install openjdk conda install -c conda-forge maven . However, this may take a day of solving environments, so you can also install it globally: . sudo apt install openjdk-11-jdk maven . If you have other versions installed, you can switch between them with the alternatives tool: . sudo update-alternatives --config java sudo update-alternatives --config javac . Now check out the original IJava and build and install the kernel IJava Jupyter kernel following the installation instructions or: . git clone https://github.com/SpencerPark/IJava.git cd IJava/ ./gradlew installKernel jupyter kernelspec list . Done. .",
            "url": "https://imglib.github.io/imglib2-blog/jupyter/ijava/jshell/java/kernel/2022/06/05/setup-ijava-jupyter-kernel.html",
            "relUrl": "/jupyter/ijava/jshell/java/kernel/2022/06/05/setup-ijava-jupyter-kernel.html",
            "date": " • Jun 5, 2022"
        }
        
    
  
    
        ,"post2": {
            "title": "Juliaset Lambda",
            "content": "Import dependencies. BigDataViewer Vistools is the convenience API that we use to display the results of our experiments and it includes all ImgLib2 related dependencies that we need. . %%loadFromPOM &lt;repository&gt; &lt;id&gt;scijava.public&lt;/id&gt; &lt;url&gt;https://maven.scijava.org/content/groups/public&lt;/url&gt; &lt;/repository&gt; &lt;dependency&gt; &lt;groupId&gt;sc.fiji&lt;/groupId&gt; &lt;artifactId&gt;bigdataviewer-vistools&lt;/artifactId&gt; &lt;version&gt;1.0.0-beta-29&lt;/version&gt; &lt;/dependency&gt; . We define the Juliaset as a function in 2D real space using a BiConsumer lambda. The BiConsumer receives two parameters, the first one (x) is the 2D coordinate, the second one (y) is the target of the function whose value will be set in place, here we use an IntType. We also have to provide a Supplier for instances of the target such that multiple threads can each create their own. . import bdv.util.*; import net.imglib2.position.FunctionRealRandomAccessible; import net.imglib2.type.numeric.integer.IntType; import net.imglib2.util.Intervals; var juliaset = new FunctionRealRandomAccessible&lt;&gt;( 2, (x, y) -&gt; { int i = 0; double v = 0, c = x.getDoublePosition(0), d = x.getDoublePosition(1); for (; i &lt; 127 &amp;&amp; v &lt; 4096; ++i) { final double e = c * c - d * d; d = 2 * c * d; c = e + 0.2; d += 0.6; v = Math.sqrt(c * c + d * d); ++i; } y.set(i); }, IntType::new); . Now we show this function with BigDataViewer. Use your mouse and keyboard to zoom in until you reach the precision limit of double. . BdvFunctions.show( juliaset, Intervals.createMinMax(-1, -1, 1, 1), &quot;&quot;, BdvOptions.options().is2D()).setDisplayRange(0, 127); . Cool? I think so! Now let&#39;s embed one of the two parameters of the Juliaset as a third dimension. The code is almost the same except that we introduce a a variable a. . var juliaset3 = new FunctionRealRandomAccessible&lt;&gt;( 3, (x, y) -&gt; { int i = 0; double v = 0, c = x.getDoublePosition(0), d = x.getDoublePosition(1), a = x.getDoublePosition(2); for (; i &lt; 127 &amp;&amp; v &lt; 4096; ++i) { final double e = c * c - d * d; d = 2 * c * d; c = e + a; d += 0.6; v = Math.sqrt(c * c + d * d); ++i; } y.set(i); }, IntType::new); . And now we show this as a 3D volume in BigDataViewer. You can scroll through the &#39;z&#39;-dimension or arbitrarily slice through the 3D volume. . BdvFunctions.show( juliaset3, Intervals.createMinMax(-1, -1, -1, 1, 1, 1), &quot;Juliaset3&quot;, BdvOptions.options()).setDisplayRange(0, 127); .",
            "url": "https://imglib.github.io/imglib2-blog/imglib2/lambda/fractal/juliaset/bigdataviewer/2022/05/02/juliaset-lambda.html",
            "relUrl": "/imglib2/lambda/fractal/juliaset/bigdataviewer/2022/05/02/juliaset-lambda.html",
            "date": " • May 2, 2022"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About",
          "content": "ImgLib2 . ImgLib2 is a general-purpose, multidimensional image and data processing library. . It provides a unified API to work with discrete and continuous n-dimensional data. This API is interface driven and therefore extensible at will. . ImgLib2 includes implementations of standard numeric and non-numeric data types (8-bit unsigned integer, 32-bit floating point, …) as well as a number of less typical data types (complex 64-bit floating point, 64-bit ARGB, base pairs, …). Data values can be accessed directly or through on-the-fly converters or multi-variate functions. . For discrete data (images, n-dimensional arrays), ImgLib2 implements a variety of memory layouts, data generation, loading, and caching strategies, including data linearized into single primitive arrays, series of arrays, n-dimensional arrays of arrays (“cells”), stored in memory, generated or loaded from disk on demand, and cached in memory or on disk. Coordinates and values can be accessed directly or through on-the-fly views that invert or permute axes, generate hyperslices or stack slices top higher dimensional datasets, collapse dimensions into vectors . For continuous data (functions, n-dimensional interpolants), ImgLib2 implements a variety of interpolators, geometric transformations, and generator functions. Coordinates and values can be accessed directly or transformed on-the-fly. . Need a quick start? Install OpenJDK and maven: . sudo apt install openjdk-16-jdk maven . Then check out BigDataViewer vistools: . git clone https://github.com/bigdataviewer/bigdataviewer-vistools.git . Then start JShell in the BigDataViewer vistools project directory: . cd bigdataviewer-vistools mvn compile com.github.johnpoth:jshell-maven-plugin:1.3:run . Then try out this code snippet: . import bdv.util.*; import net.imglib2.position.FunctionRealRandomAccessible; import net.imglib2.type.numeric.integer.IntType; import net.imglib2.util.Intervals; BdvFunctions.show(new FunctionRealRandomAccessible&lt;IntType&gt;(2, (x, y) -&gt; { int i = 0; double v = 0, c = x.getDoublePosition(0), d = x.getDoublePosition(1); for (; i &lt; 64 &amp;&amp; v &lt; 4096; ++i) { final double e = c * c - d * d; d = 2 * c * d; c = e + 0.2; d += 0.6; v = Math.sqrt(c * c + d * d); ++i; } y.set(i); }, IntType::new), Intervals.createMinMax(-1, -1, 1, 1), &quot;&quot;, BdvOptions.options().is2D()).setDisplayRange(0, 64); .",
          "url": "https://imglib.github.io/imglib2-blog/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://imglib.github.io/imglib2-blog/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}